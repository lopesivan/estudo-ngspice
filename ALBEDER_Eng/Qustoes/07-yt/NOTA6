Boa ğŸ‘Œ vocÃª jÃ¡ usou o `.meas` do **ngspice** do jeito certo para achar o **mÃ¡ximo**. Agora vamos aos outros casos:

---

## ğŸ”¹ Corrente RMS

O ngspice jÃ¡ tem operador RMS embutido:

```spice
.meas tran I_L_rms RMS i(L1) FROM=20ms TO=40ms
```

Isso te dÃ¡ o **valor eficaz** da corrente no intervalo especificado (nesse caso, de 20 ms a 40 ms â†’ depois do regime jÃ¡ estabelecido).

---

## ğŸ”¹ MÃ³dulo e argumento (magnitude e fase)

Aqui depende do tipo de simulaÃ§Ã£o:

### 1. **Se vocÃª estÃ¡ em transiente (`.tran`)**

* O `.meas` nÃ£o tem comando direto para â€œfaseâ€ no tempo.
* VocÃª pode calcular o **valor mÃ©dio quadrÃ¡tico** (RMS) e o **valor mÃ©dio** mas nÃ£o o Ã¢ngulo fÃ¡sico diretamente.
* Para achar o argumento, normalmente se mede o **tempo do cruzamento em zero** da corrente e compara com o da tensÃ£o de referÃªncia.
  Exemplo:

  ```spice
  .meas tran tV  TRIG v(1) VAL=0 RISE=1
  .meas tran tI  TARG i(L1) VAL=0 RISE=1
  ```

  Depois a diferenÃ§a `tI - tV` dÃ¡ o atraso em segundos â†’ multiplica por `2Ï€f` â†’ fase em rad.

### 2. **Se vocÃª estÃ¡ em AC analysis (`.ac`)**

Muito mais fÃ¡cil ğŸ™‚

* Em `.ac` vocÃª jÃ¡ estÃ¡ trabalhando no domÃ­nio fasorial.
* O ngspice retorna diretamente mÃ³dulo e fase de qualquer grandeza.
* Para medir corrente do indutor:

  ```spice
  .print ac i(L1)
  ```

  Isso te dÃ¡ a parte real e imaginÃ¡ria.
* Se quiser magnitude e fase direto:

  ```spice
  .print ac mag(i(L1)) phase(i(L1))
  ```

  â†’ `mag(i(L1))` Ã© o mÃ³dulo (A),
  â†’ `phase(i(L1))` Ã© o argumento (graus).

---

âœ… EntÃ£o:

* Use `.tran` se quiser **formas de onda no tempo** e RMS.
* Use `.ac` se quiser **mÃ³dulo e argumento de fasores** diretamente.

---

ğŸ‘‰ Quer que eu adapte seu netlist com um bloco de `.meas` que jÃ¡ calcule:

* `I_L_max`
* `I_L_rms`
* `|I_L|` e `âˆ I_L` (na anÃ¡lise AC)

tudo pronto para rodar?

